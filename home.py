# -*- coding: utf-8 -*-
"""ã€ŒæœŸæœ«baseball!!ã€_è‡ªå·±try

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EwcafHnSLcUwH1n94t89fDzZtk5Tr1wt

# ç’°å¢ƒè¨­å®š
"""

import pandas as pd
import numpy as np
from bs4 import BeautifulSoup
import requests
import os

import plotly.express as px
import plotly.graph_objects as go

import joblib
from scipy import stats
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.ensemble import VotingRegressor
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler

from catboost import CatBoostRegressor
from xgboost import XGBRegressor
from lightgbm import LGBMRegressor

from google import genai
from google.colab import files, userdata
from pyngrok import ngrok

"""# streamlit"""

os.makedirs("shared", exist_ok=True)
os.makedirs("pages", exist_ok=True)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile shared/__init__.py

os.makedirs('.streamlit', exist_ok=True)

with open('.streamlit/config.toml', 'w') as f:
    f.write("""
[theme]
primaryColor = "#E31837"
backgroundColor = "#FFFFFF"
secondaryBackgroundColor = "#001844"
textColor = "#333333"
font = "sans serif"
""")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile shared/resources.py
# import streamlit as st
# import joblib
# import pandas as pd
# import numpy as np
# import os
# 
# MODEL_URL = "https://raw.githubusercontent.com/ChewyChloe/cpbl-project/main/cpbl_ai_model.pkl"
# DATA_URL = "https://raw.githubusercontent.com/ChewyChloe/cpbl-project/cb8796cfbf8aa99126c7aeb3044f80569b1b5ff5/team_stats_recent.csv"
# 
# @st.cache_resource
# def load_resources():
#     if not os.path.exists("cpbl_ai_model.pkl"):
#         os.system(f"wget -q -O cpbl_ai_model.pkl {MODEL_URL}")
# 
#     try:
#         model = joblib.load("cpbl_ai_model.pkl")
#     except Exception:
#         model = None
# 
#     if not os.path.exists("team_stats_recent.csv"):
#         os.system(f"wget -q -O team_stats_recent.csv {DATA_URL}")
# 
#     try:
#         df = pd.read_csv("team_stats_recent.csv")
#     except Exception:
#         df = None
# 
#     return model, df
# 
# 
# def calculate_pythagorean_win_rate(runs_scored, runs_allowed):
#     exponent = 1.83
#     if (runs_scored + runs_allowed) == 0:
#         return 0.5
#     return (runs_scored ** exponent) / ((runs_scored ** exponent) + (runs_allowed ** exponent))

"""### CSS"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile shared/styles.py
# import streamlit as st
# 
# custom_css = """
# <style>
# /* å…¨å±€ */
# .stApp { background-color: #F8F9FA; }
# 
# /* å´æ¬„ */
# section[data-testid="stSidebar"] {
#     background-color: #001844 !important;
# }
# section[data-testid="stSidebar"] * {
#     color: #FFFFFF !important;
# }
# 
# /* ä¸‹æ‹‰é¸å–® */
# div[data-baseweb="select"] > div,
# input[type="number"]{
#   color:white !important;
#   background-color:#002D62 !important;
#   border-radius:5px;
# }
# ul[data-baseweb="menu"] li{
#   color:black !important;
# }
# 
# .stSelectbox label, .stNumberInput label, .stSlider label{
#   color:#333333 !important;
#   font-weight:bold;
# }
# 
# /* éš±è—åŸç”Ÿå…ƒä»¶ */
# #MainMenu {visibility:hidden;}
# footer {visibility:hidden;}
# 
# /* åœ˜éšŠå¡èˆ‡ Podcast å¡ */
# .podcast-card{
#   background-color:#FFFFFF;
#   border-radius:12px;
#   box-shadow:0 4px 12px rgba(0,0,0,0.08);
#   padding:15px;
#   margin-bottom:20px;
#   border:1px solid #e0e0e0;
#   transition:transform 0.2s, box-shadow 0.2s;
#   display:flex;
#   flex-direction:column;
#   align-items:center;
#   text-align:center;
# }
# .podcast-card:hover{
#   transform:translateY(-5px);
#   box-shadow:0 8px 20px rgba(0,0,0,0.15);
# }
# .podcast-card h3{
#   color:#001844;
#   font-size:18px;
#   font-weight:700;
#   margin-top:15px;
#   margin-bottom:5px;
#   text-align:center;
# }
# .video-container{
#   position:relative;
#   width:100%;
#   padding-bottom:56.25%;
#   height:0;
#   overflow:hidden;
#   border-radius:8px;
# }
# .video-container iframe{
#   position:absolute;
#   top:0; left:0;
#   width:100%;
#   height:100%;
#   border:0;
# }
# 
# /* é–‹ç™¼åœ˜éšŠ */
# .team-card{
#   background-color:#FFF5F7;
#   border:2px solid #FFD1DC;
#   border-radius:20px;
#   padding:20px;
#   text-align:center;
#   margin-bottom:20px;
#   box-shadow:0 4px 10px rgba(255,182,193,0.2);
#   transition:transform 0.3s ease;
#   height: 100%;
# }
# .team-card:hover{
#   transform:translateY(-5px);
#   box-shadow:0 8px 15px rgba(255,182,193,0.5);
# }
# .team-name{
#   color:#001844;
#   font-size:20px;
#   font-weight:bold;
#   margin-bottom:5px;
# }
# .team-info{
#   color:#666;
#   font-size:14px;
#   margin:2px 0;
# }
# 
# /* AI å°è©±æ¡† */
# textarea[data-testid="stChatInputTextArea"] {
#     color: #FFFFFF !important;
#     caret-color: #FFFFFF !important;
# }
# textarea[data-testid="stChatInputTextArea"]::placeholder {
#     color: #DDDDDD !important;
#     opacity: 1;
# }
# </style>
# """
# 
# def apply_global_style():
#     st.markdown(custom_css, unsafe_allow_html=True)

"""### é¦–é """

# Commented out IPython magic to ensure Python compatibility.
# %%writefile é¦–é .py
# import os
# import sys
# import streamlit as st
# from shared.styles import apply_global_style
# from shared.resources import load_resources
# sys.path.append(os.path.dirname(os.path.abspath(__file__)))
# 
# st.set_page_config(layout='wide', page_title='CPBL æ£’çƒåˆ†æç³»çµ±')
# 
# apply_global_style()
# 
# model, df_stats = load_resources()
# 
# # ä¸»é 
# st.markdown("""
# <div style="background-color: #001844; padding: 2rem; border-radius: 1rem; color: white; margin-bottom: 2rem;">
#     <h1 style='color: white; margin:0;'>CPBL æ£’çƒåˆ†æç³»çµ±</h1>
#     <p style='color: #cbd5e1; margin-top: 10px;'>å¸¶ä½ ä¸€èµ·èªè­˜æ£’çƒ!!</p>
# </div>
# """, unsafe_allow_html=True)
# 
# m1, m2, m3 = st.columns(3)
# m1.metric("æ¨¡å‹æº–ç¢ºç‡", "95.9%", "é«˜æº–ç¢ºç‡")
# m2.metric("å·²åŸ·è¡Œé æ¸¬", "761 å ´", "å ´å ´æ”¶éŒ„")
# m3.metric("æ­·å²æ•¸æ“šåº«", "35 å¹´", "å¹´å¹´éƒ½æœ‰")
# 
# st.markdown("### ğŸ§ç›¸é—œå½±ç‰‡")
# 
# podcasts = [
#     {"title": "æ£’çƒå ±ä½ çŸ¥ Podcast EP.1 ä¸­è·å»ºè»å¤§æ´—ç‰Œ", "video_id": "68C5TK90YGk"},
#     {"title": "å°ç£å¤§è³½ Game 5 ç¸½å† è»è³½ç²¾è¯ç‰‡æ®µ", "video_id": "emVgQV6UyIM"}
# ]
# 
# cols = st.columns(len(podcasts) if len(podcasts) > 0 else 1)
# if len(podcasts) == 1:
#     cols = [st.columns([1, 2, 1])[1]]
# 
# for i, podcast in enumerate(podcasts):
#     with cols[i]:
#         embed_url = f"https://www.youtube.com/embed/{podcast['video_id']}"
#         card_html = f"""
#         <div class="podcast-card">
#             <div class="video-container">
#                 <iframe src="{embed_url}" title="YouTube video player"
#                 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
#                 allowfullscreen></iframe>
#             </div>
#             <h3>{podcast['title']}</h3>
#         </div>
#         """
#         st.markdown(card_html, unsafe_allow_html=True)

"""### æœªä¾†è³½äº‹é æ¸¬"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile pages/2_ğŸ”®_æœªä¾†è³½äº‹é æ¸¬.py
# import streamlit as st
# import numpy as np
# import pandas as pd
# import plotly.graph_objects as go
# import os
# import joblib
# from sklearn.preprocessing import StandardScaler
# from shared.styles import apply_global_style
# 
# GITHUB_BASE = "https://raw.githubusercontent.com/ChewyChloe/cpbl-project/main/"
# MODEL_URL = GITHUB_BASE + "cpbl_ai_model.pkl"
# META_MODEL_URL = GITHUB_BASE + "cpbl_meta_learner.pkl"
# SCALER_URL = GITHUB_BASE + "scaler.pkl"
# BATTER_DATA_URL = GITHUB_BASE + "player_features_for_app.csv"
# PITCHER_DATA_URL = GITHUB_BASE + "pitcher_stats_for_app.csv"
# 
# PARK_FACTORS = {
#     "æ´²éš›": {"Runs": 1.19}, "æ¾„æ¸…æ¹–": {"Runs": 1.03}, "å¤©æ¯": {"Runs": 0.96},
#     "æ–°èŠ": {"Runs": 0.90}, "æ¨‚å¤©æ¡ƒåœ’": {"Runs": 1.18}, "å°å—": {"Runs": 0.91},
#     "å°åŒ—å¤§å·¨è›‹": {"Runs": 0.84}
# }
# 
# STADIUM_MAP = {
#     "çµ±ä¸€7-ELEVEnç…": ["å°å—"], "ä¸­ä¿¡å…„å¼Ÿ": ["æ´²éš›"], "æ¨‚å¤©æ¡ƒçŒ¿": ["æ¨‚å¤©æ¡ƒåœ’"],
#     "å‘³å…¨é¾": ["å¤©æ¯", "å°åŒ—å¤§å·¨è›‹"], "å¯Œé‚¦æ‚å°‡": ["æ–°èŠ"], "å°é‹¼é›„é·¹": ["æ¾„æ¸…æ¹–"]
# }
# 
# TEAM_ROSTERS = {
#     "çµ±ä¸€7-ELEVEnç…": {
#         "pitchers": ["é™³éŸ»æ–‡", "è’™å¾·èŒ²", "åŠ‰äºˆæ‰¿", "é«™å¡©å°‡æ¨¹", "é¾å…è¯", "é‚±æµ©éˆ", "ç‹é¡éŠ˜", "ç…å¸èŠ¬", "å³æ‰¿è«­", "èƒ¡æ™ºçˆ²", "æè»", "è¾›ä¿Šæ˜‡", "éƒ­ä¿ŠéºŸ", "é£›åŠ›ç…"],
#         "batters": ["é™³å‚‘æ†²", "æ—å®‰å¯", "è˜‡æ™ºå‚‘", "é™³éåŸº", "æ½˜å‚‘æ¥·", "é‚±æ™ºå‘ˆ", "é™³è–å¹³", "é™³é‡ç¾½", "æ—ä½³ç·¯", "èƒ¡é‡‘é¾", "æ—å­è±ª", "è¨±å“²æ™", "é™³é‡å»·", "æ—æ³“å¼¦", "æ—ç¥–å‚‘", "æ—å²±å®‰", "æŸ¯è‚²æ°‘", "æœ±è¿¦æ©"]
#     },
#     "å°é‹¼é›„é·¹": {
#         "pitchers": ["æ±Ÿæ‰¿è«º", "é™³æŸæ¸…", "è‰¾é€Ÿç‰¹", "é»ƒç¾¤", "ç‹èºéœ–", "æ—è©©ç¿”", "éŸ‹å®äº®", "é»ƒç´¹ç¿", "æ«»äº•å‘¨æ–—", "è¨±è‚²éŠ˜", "å¼µèª æ©", "éƒ­ä¿å»¶"],
#         "batters": ["é­”é·¹", "æ›¾å­ç¥", "ç‹æŸè", "å³å¿µåº­", "ç‹åšç„", "æœå®¶æ˜", "éƒ­é˜œæ—", "éƒ­æ°¸ç¶­", "è‘‰ä¿å¼Ÿ", "é™³æ–‡æ°", "è—å¯…å€«", "ç´€æ…¶ç„¶", "é¡éƒè»’", "æ—å®¶é‹", "æ›¾æ˜±ç£¬", "é«˜è–æ©", "é™³è‡´å˜‰", "é™³ä¸–å˜‰"]
#     },
#     "ä¸­ä¿¡å…„å¼Ÿ": {
#         "pitchers": ["å¾·ä¿æ‹‰", "å‘‚å½¥é’", "å³ä¿Šå‰", "è”¡é½Šå“²", "ææŒ¯æ˜Œ", "é„­å‡±æ–‡", "é­ç¢©æˆ", "æ—æš‰ç››", "æ±Ÿå¿ åŸ", "ç¾…æˆˆ", "é„­æµ©å‡", "æåšç™»", "ç›§å­Ÿæš", "ä¼ç«‹è¾°", "éŸ‹ç¦®åŠ "],
#         "batters": ["æ±Ÿå¤å®‡", "ç‹å¨æ™¨", "è¨±åŸºå®", "é™³ä¿Šç§€", "å²³æ”¿è¯", "æ›¾é Œæ©", "è©¹å­è³¢", "å²³æ±è¯", "é«˜å®‡æ°", "å¼µå¿—è±ª", "ç‹æ”¿é †", "æ—å¿—ç¶±", "å¼µä»ç‘‹", "é»ƒéŸ‹ç››", "è¨±åº­ç¶¸", "å®‹æ™Ÿç¿", "é™³çµ±æ©", "å¾åšç‘‹"]
#     },
#     "æ¨‚å¤©æ¡ƒçŒ¿": {
#         "pitchers": ["å¨èƒ½å¸", "é­”ç¥æ¨‚", "é»ƒå­éµ¬", "é™³å† å®‡", "é™³æŸè±ª", "è˜‡ä¿Šç’‹", "èŠæ˜•è«º", "ç‹å¿—ç…Š", "è³´èƒ¤è±ª", "æœ±æ‰¿æ´‹", "å‡±æ¨‚", "é‚±é§¿å¨", "æ—å­å´´", "é™³å…‹ç¾¿"],
#         "batters": ["æ—ç«‹", "æ¢å®¶æ¦®", "å»–å¥å¯Œ", "é™³æ™¨å¨", "æ—æ‰¿é£›", "æœ±è‚²è³¢", "æ—æ³“è‚²", "é¦¬å‚‘æ£®", "æ—å­å‰", "æ—æ™ºå¹³", "æˆæ™‰", "ä½™å¾·é¾", "æ—æ”¿è¯", "ä½•å“å®¤è", "é¾ç‰æˆ", "è¨±è³€æ·", "æå‹›å‚‘", "å®‹å˜‰ç¿”", "å¼µé–”å‹›", "åš´å®éˆ"]
#     },
#     "å‘³å…¨é¾": {
#         "pitchers": ["å¾è‹¥ç†™", "é‹¼é¾", "é™³å† å‰", "æ—å‡±å¨", "æ—å­æ˜±", "éƒ­éƒæ”¿", "é™³ç¦¹å‹³", "æ›¹ç¥é½Š", "å¼µæ™¯æ·¯", "å‘‚å‰æ™Ÿ", "æè‡´éœ–", "è¶™ç’Ÿæ¦®", "é™³å¿—æ°", "å¼µéˆå®ˆ", "é»ƒæšå‚‘", "æ—é‹…æ°"],
#         "batters": ["å‰åŠ›å‰æ’ˆï¼éå† ", "æå‡±å¨", "åŠ‰åŸºé´»", "éƒ­å¤©ä¿¡", "å¼µæ”¿ç¦¹", "è”£å°‘å®", "æ‹¿è«ï¼ä¼Šæ¼¾", "æ—å­ç¨‹", "åŠ‰ä¿Šç·¯", "é™³æ€ä»²", "å‘¨å§”å®", "ç‘ªä»•é©æ–¯ï¼ä¿„éœ¸å¾‹å°¼", "æœ±è‚²è³¢", "ç‹é †å’Œ", "å¼µç¥éŠ˜", "å¼µç¥å˜‰", "æ—è¾°å‹³"]
#     },
#     "å¯Œé‚¦æ‚å°‡": {
#         "pitchers": ["æ›¾å³»å²³", "ç‹å°‰æ°¸", "æ±Ÿåœ‹è±ª", "é»ƒä¿ç¾…", "è³´é´»èª ", "å»–ä»»ç£Š", "èŒƒæŸçµœ", "æå³æ°¸å‹¤", "é­”åŠ›è—", "åŠ›äºå£«", "æ¸¸éœ†å´´", "æ—æ šå‘ˆ"],
#         "batters": ["å¼µè‚²æˆ", "ç”³çš“ç‘‹", "èŒƒåœ‹å®¸", "æˆ´åŸ¹å³°", "ç‹æ­£æ£ ", "è‘£å­æ©", "ç‹å¿µå¥½", "æ± æ©é½Š", "æå®—è³¢", "æ—æ¾¤å½¬", "é«˜æ·", "è‘‰å­éœ†", "é»ƒå…†ç¶­", "æ—å²³è°·", "æ½˜ç‘‹ç¥¥", "é™³çœŸ", "å¼µæ´ºç‘€", "è”¡ä½³è«º", "å‘¨ä½³æ¨‚", "è±Šæš", "é­å…¨"]
#     }
# }
# 
# @st.cache_resource
# def load_all_resources():
#     files = {"model.pkl": MODEL_URL, "meta.pkl": META_MODEL_URL, "scaler.pkl": SCALER_URL, "bat.csv": BATTER_DATA_URL, "pit.csv": PITCHER_DATA_URL}
#     for name, url in files.items():
#         if not os.path.exists(name): os.system(f"wget -q -O {name} {url}")
# 
#     df_b = pd.read_csv("bat.csv")
#     df_p = pd.read_csv("pit.csv")
#     df_b.columns = df_b.columns.str.strip()
#     df_p.columns = df_p.columns.str.strip()
# 
#     return joblib.load("model.pkl"), joblib.load("meta.pkl"), joblib.load("scaler.pkl"), df_b, df_p
# 
# model, meta_model, scaler, df_bat, df_pit = load_all_resources()
# 
# first_est = model.estimators_[0]
# current_order = first_est.feature_names_ if hasattr(first_est, 'feature_names_') else first_est.feature_names_in_
# 
# apply_global_style()
# st.header("ğŸ”® 2026 æ£’çƒæ¯”è³½é æ¸¬ç³»çµ±")
# 
# col_h, col_vs, col_a = st.columns([1, 0.2, 1])
# with col_h:
#     st.subheader("ğŸ  ä¸»éšŠ (Home)")
#     h_team = st.selectbox("é¸æ“‡ä¸»éšŠ", list(STADIUM_MAP.keys()), key="h_t")
#     h_stadium = st.selectbox("ğŸŸï¸ æ¯”è³½çƒå ´", STADIUM_MAP[h_team], key="h_st")
#     h_sp = st.selectbox("âš¾ é¸æ“‡å…ˆç™¼æŠ•æ‰‹", TEAM_ROSTERS[h_team]["pitchers"], key="h_p")
#     h_lineup = st.multiselect("ğŸ“‹ é¸æ“‡æ‰“ç·š (9äºº)", TEAM_ROSTERS[h_team]["batters"], key="h_l")
# 
# with col_a:
#     st.subheader("âœˆï¸ å®¢éšŠ (Away)")
#     a_team = st.selectbox("é¸æ“‡å®¢éšŠ", [t for t in STADIUM_MAP.keys() if t != h_team], key="a_t")
#     a_sp = st.selectbox("é¸æ“‡å…ˆç™¼æŠ•æ‰‹", TEAM_ROSTERS[a_team]["pitchers"], key="a_p")
#     a_lineup = st.multiselect("é¸æ“‡æ‰“ç·š (9äºº)", TEAM_ROSTERS[a_team]["batters"], key="a_l")
# 
# if st.button("ğŸš€ åŸ·è¡Œé æ¸¬", use_container_width=True):
#     if len(h_lineup) != 9 or len(a_lineup) != 9:
#         st.warning("âš ï¸ è«‹ç¢ºä¿å…©éšŠçš†é¸æ»¿ 9 ä½æ‰“è€…ã€‚")
#     else:
#         with st.spinner("æ­£åœ¨è§£æ..."):
# 
#             def get_team_wraa(names, expected_order):
#                 wraa_total = 0
#                 found_names = []
#                 for name in names:
#                     hist = df_bat[
#                         (df_bat['Name_Display'].str.strip() == name.strip()) &
#                         (df_bat['Year_Display'].isin([2024, 2025]))
#                     ].sort_values('Year_Display', ascending=False)
# 
#                     if not hist.empty:
#                         found_names.append(name)
#                         weights = [0.7, 0.3]
#                         vals = []
#                         for i in range(min(2, len(hist))):
#                             row = hist.iloc[[i]]
#                             feat_raw = row.drop(columns=['Name_Display','Team_Display','Year_Display','Real_OPS'], errors='ignore')
#                             feat_aligned = feat_raw.reindex(columns=expected_order, fill_value=0)
#                             feat_aligned = feat_aligned.apply(pd.to_numeric, errors='coerce').fillna(0)
#                             vals.append(model.predict(feat_aligned)[0])
# 
#                         w_use = weights[:len(vals)]
#                         if sum(w_use) > 0:
#                             w_norm = [w/sum(w_use) for w in w_use]
#                             wraa_total += np.average(vals, weights=w_norm)
#                 return wraa_total, found_names
# 
#             # è¨ˆç®—æ‰“æ“Šèˆ‡æŠ•æ‰‹æ•¸æ“š
#             h_wraa, h_found = get_team_wraa(h_lineup, current_order)
#             a_wraa, a_found = get_team_wraa(a_lineup, current_order)
# 
#             def get_fip(name):
#                 name_col = 'Name' if 'Name' in df_pit.columns else 'Name_Display'
#                 res = df_pit[df_pit[name_col].str.strip() == name.strip()].sort_values('Year', ascending=False)['FIP']
#                 return res.values[0] if not res.empty else 4.2
# 
#             h_fip, a_fip = get_fip(h_sp), get_fip(a_sp)
#             pf_val = PARK_FACTORS[h_stadium]["Runs"]
# 
#             # é æ¸¬è¨ˆç®—
#             wraa_diff = h_wraa - a_wraa
#             fip_diff = a_fip - h_fip
# 
#             X_raw = np.array([[wraa_diff, fip_diff, pf_val]])
#             X_scaled = scaler.transform(X_raw)
#             win_prob_raw = meta_model.predict_proba(X_scaled)[0][1]
# 
#             # é‚è¼¯ä¿®æ­£
#             adjustment = 0.33
#             logit_raw = np.log(win_prob_raw / (1 - win_prob_raw))
#             logit_final = logit_raw + adjustment
#             win_prob = 1 / (1 + np.exp(-logit_final))
#             win_prob = np.clip(win_prob, 0.05, 0.95)
# 
#             # è¨ºæ–·é¢æ¿
#             with st.expander("ğŸ” æ•¸æ“šè¨ºæ–·èˆ‡è¨ˆç®—éç¨‹"):
#                 st.markdown("### 1. æ‰“æ“Šæˆ°åŠ› (wRAA)")
#                 st.write(f"- ä¸»éšŠç¸½é ä¼° wRAA: `{h_wraa:.2f}`")
#                 st.write(f"- å®¢éšŠç¸½é ä¼° wRAA: `{a_wraa:.2f}`")
#                 st.info(f"ğŸ’¡ **æ‰“æ“Šå·®è· (wraa_diff)** = `{wraa_diff:.2f}`")
# 
#                 st.markdown("---")
#                 st.markdown("### 2. æŠ•æ‰‹å£“åˆ¶åŠ› (FIP)")
#                 st.write(f"- ä¸»éšŠå…ˆç™¼ ({h_sp}) FIP: `{h_fip:.2f}`")
#                 st.write(f"- å®¢éšŠå…ˆç™¼ ({a_sp}) FIP: `{a_fip:.2f}`")
#                 st.info(f"ğŸ’¡ **æŠ•æ‰‹å·®è· (fip_diff)** = `{fip_diff:.2f}`")
# 
#                 st.markdown("---")
#                 st.markdown("### 3. æœ€çµ‚æ¨è«–èˆ‡ä¿®æ­£")
#                 st.write(f"- çƒå ´å› å­ (PF): `{pf_val:.2f}`")
#                 st.write(f"- æ¨¡å‹åŸå§‹é æ¸¬: `{win_prob_raw*100:.2f}%`")
# 
#                 st.latex(r"Logit_{raw} = \ln\left(\frac{P_{raw}}{1-P_{raw}}\right) = " + f"{logit_raw:.3f}")
#                 st.write(f"- ä¸»å ´ä¿®æ­£å¼·åº¦: `+{adjustment}`")
#                 st.latex(r"Prob_{final} = \frac{1}{1 + e^{-(Logit_{raw} + " + str(adjustment) + ")}}")
# 
#                 st.success(f"ä¿®æ­£å¾Œæœ€çµ‚å‹ç‡: **{win_prob*100:.2f}%**")
# 
#             # åœ–è¡¨
#             fig = go.Figure(go.Indicator(
#                 mode = "gauge+number", value = win_prob * 100,
#                 title = {'text': f"{h_team} å‹ç‡é ä¼° (%)"},
#                 gauge = {
#                     'axis': {'range': [0, 100]},
#                     'bar': {'color': "#002D62"},
#                     'steps': [
#                         {'range': [0, 45], 'color': "#FFCCCC"},
#                         {'range': [45, 55], 'color': "#EEEEEE"},
#                         {'range': [55, 100], 'color': "#CCFFCC"}
#                     ]
#                 }
#             ))
#             st.plotly_chart(fig, use_container_width=True)
# 
#             if win_prob > 0.55: st.success(f"**AI è©•è«–**ï¼š{h_team} åœ¨ {h_stadium} å…·æœ‰æ˜é¡¯å„ªå‹¢ã€‚")
#             elif win_prob < 0.45: st.error(f"**AI è©•è«–**ï¼šå®¢éšŠ {a_team} çš„æˆ°åŠ›é æœŸè¼ƒç‚ºå¼·å‹¢ã€‚")
#             else: st.info("**AI è©•è«–**ï¼šé›™æ–¹æˆ°åŠ›å¹³è¡¡ï¼Œä¸»å ´å› ç´ å°‡æ˜¯å‹è² é—œéµã€‚")

"""### æ•¸æ“šå„€è¡¨æ¿"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile pages/1_ğŸ“Š_æ•¸æ“šå„€è¡¨æ¿.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import plotly.express as px
# import plotly.graph_objects as go
# import sys
# import os
# 
# sys.path.append(os.path.abspath('.'))
# try:
#     from shared import styles
# except ImportError:
#     pass
# 
# st.set_page_config(page_title="CPBL æ•¸æ“šå„€è¡¨æ¿", layout="wide")
# st.title("âš¾ CPBL è·æ£’æ•¸æ“šåˆ†æä¸­å¿ƒ")
# 
# @st.cache_data
# def load_data():
#     try:
#         df = pd.read_csv('baseball_data.csv')
#     except FileNotFoundError:
#         st.error("æ‰¾ä¸åˆ° 'baseball_data.csv'")
#         return pd.DataFrame(), pd.DataFrame()
# 
#     cols_to_numeric = ['bat_PA', 'pit_IP', 'pit_ER', 'pit_BB', 'pit_H', 'pit_SO']
#     for col in cols_to_numeric:
#         if col in df.columns:
#             df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0)
# 
#     team_name_map = {
#         'çµ±ä¸€ç…': 'çµ±ä¸€7-ELEVEnç…', 'çµ±ä¸€': 'çµ±ä¸€7-ELEVEnç…', 'Uni-Lions': 'çµ±ä¸€7-ELEVEnç…',
#         'æ¡ƒçŒ¿': 'æ¨‚å¤©æ¡ƒçŒ¿', 'Lamigo': 'æ¨‚å¤©æ¡ƒçŒ¿', 'Rakuten': 'æ¨‚å¤©æ¡ƒçŒ¿', 'æ¨‚å¤©': 'æ¨‚å¤©æ¡ƒçŒ¿',
#         'å…„å¼Ÿ': 'ä¸­ä¿¡å…„å¼Ÿ', 'å…„å¼Ÿè±¡': 'ä¸­ä¿¡å…„å¼Ÿ', 'Brothers': 'ä¸­ä¿¡å…„å¼Ÿ',
#         'å¯Œé‚¦': 'å¯Œé‚¦æ‚å°‡', 'æ‚å°‡': 'å¯Œé‚¦æ‚å°‡', 'ç¾©å¤§': 'å¯Œé‚¦æ‚å°‡', 'ç¾©å¤§çŠ€ç‰›': 'å¯Œé‚¦æ‚å°‡',
#         'å‘³å…¨': 'å‘³å…¨é¾', 'Dragons': 'å‘³å…¨é¾',
#         'å°é‹¼': 'å°é‹¼é›„é·¹', 'TSG': 'å°é‹¼é›„é·¹'
#     }
#     target_teams = ['çµ±ä¸€7-ELEVEnç…', 'å°é‹¼é›„é·¹', 'ä¸­ä¿¡å…„å¼Ÿ', 'æ¨‚å¤©æ¡ƒçŒ¿', 'å‘³å…¨é¾', 'å¯Œé‚¦æ‚å°‡']
# 
#     # æ‰“è€…è³‡æ–™
#     bat_cols = ['Name_clean', 'Team Name_x', 'Year', 'bat_PA', 'bat_AB', 'bat_H', 'bat_HR', 'bat_SB', 'bat_AVG', 'bat_OPS', 'bat_OBP', 'bat_SLG']
#     valid_bat_cols = [c for c in bat_cols if c in df.columns]
# 
#     df_sorted_bat = df[valid_bat_cols].sort_values(by=['Year', 'bat_PA'], ascending=[False, False])
#     df_bat = df_sorted_bat.drop_duplicates(subset=['Name_clean', 'Year'], keep='first')
# 
#     df_bat = df_bat.rename(columns={'Name_clean': 'Name', 'Team Name_x': 'Team', 'bat_OPS': 'OPS', 'bat_AVG': 'AVG', 'bat_HR': 'HR', 'bat_SB': 'SB', 'bat_PA': 'PA'})
#     df_bat['Team'] = df_bat['Team'].replace(team_name_map)
#     df_bat = df_bat[df_bat['Team'].isin(target_teams)]
#     df_bat = df_bat[df_bat['PA'] > 0]
# 
#     # æŠ•æ‰‹è³‡æ–™
#     df_pit_raw = df[ (df['pit_IP'] > 0) & (df['bat_PA'] < 10) ].copy()
# 
#     if 'pit_ER' in df_pit_raw.columns and 'pit_IP' in df_pit_raw.columns:
#         df_pit_raw['pit_ERA'] = (df_pit_raw['pit_ER'] * 9) / df_pit_raw['pit_IP'].replace(0, 0.1)
#     else:
#         df_pit_raw['pit_ERA'] = 0.0
# 
#     if 'pit_BB' in df_pit_raw.columns and 'pit_H' in df_pit_raw.columns:
#          df_pit_raw['pit_WHIP'] = (df_pit_raw['pit_BB'] + df_pit_raw['pit_H']) / df_pit_raw['pit_IP'].replace(0, 0.1)
#     else:
#         df_pit_raw['pit_WHIP'] = 0.0
# 
#     pit_cols = ['Name_clean', 'Team Name_y', 'Year', 'pit_ERA', 'pit_IP', 'pit_SO', 'pit_BB', 'pit_WHIP']
#     valid_pit_cols = [c for c in pit_cols if c in df_pit_raw.columns]
# 
#     df_sorted_pit = df_pit_raw[valid_pit_cols].sort_values(by=['Year', 'pit_IP'], ascending=[False, False])
#     df_pit = df_sorted_pit.drop_duplicates(subset=['Name_clean', 'Year'], keep='first')
# 
#     df_pit = df_pit.rename(columns={'Name_clean': 'Name', 'Team Name_y': 'Team', 'pit_ERA': 'ERA', 'pit_IP': 'IP', 'pit_SO': 'SO', 'pit_BB': 'BB', 'pit_WHIP': 'WHIP'})
#     df_pit['Team'] = df_pit['Team'].fillna('Unknown')
#     df_pit['Team'] = df_pit['Team'].replace(team_name_map)
#     df_pit = df_pit[df_pit['Team'].isin(target_teams)]
# 
#     return df_bat, df_pit
# 
# df_bat, df_pit = load_data()
# 
# # åˆ†é å…§å®¹
# tab1, tab2, tab3 = st.tabs(["ğŸ† è¯ç›Ÿæˆ°æ³", "ğŸ æ‰“æ“Šæ’è¡Œ", "âš¾ æŠ•æ‰‹åˆ†æ"])
# 
# def get_weighted_average(data, value_col, weight_col):
#     if data[weight_col].sum() == 0: return 0
#     return np.average(data[value_col], weights=data[weight_col])
# 
# # Tab 1: è¯ç›Ÿæˆ°æ³
# with tab1:
#     st.subheader("ğŸ› ï¸ ç¯©é¸æ¢ä»¶")
#     all_years = sorted(df_bat['Year'].unique())
#     def_year = [2024] if 2024 in all_years else ([max(all_years)] if all_years else [])
# 
#     t1_years = st.multiselect("é¸æ“‡å¹´ä»½ (åƒ…å½±éŸ¿ä¸‹æ–¹æ°£æ³¡åœ–)", all_years, default=def_year, key="t1_year")
# 
#     # è³‡æ–™ç¯©é¸
#     bat_t1 = df_bat[df_bat['Year'].isin(t1_years)]
#     pit_t1 = df_pit[df_pit['Year'].isin(t1_years)]
# 
#     st.divider()
#     st.header("åœ˜éšŠæˆ°åŠ›åˆ†æ")
# 
#     col1, col2 = st.columns(2)
# 
#     with col1:
#         st.subheader("ğŸ“ˆ åœ˜éšŠ OPS å¹´åº¦è¶¨å‹¢")
#         team_ops_trend = df_bat.groupby(['Year', 'Team']).apply(
#             lambda x: pd.Series({'OPS': get_weighted_average(x, 'OPS', 'PA')})
#         ).reset_index()
# 
#         if not team_ops_trend.empty:
#             fig_trend = px.line(team_ops_trend, x='Year', y='OPS', color='Team', markers=True)
#             st.plotly_chart(fig_trend, use_container_width=True)
# 
#     with col2:
#         st.subheader("ğŸ›¡ï¸ æ¯”è¼ƒæ”»å®ˆè¡¨ç¾ï¼šOPS vs ERA")
#         team_ops_now = bat_t1.groupby(['Year', 'Team']).apply(
#             lambda x: pd.Series({'OPS': get_weighted_average(x, 'OPS', 'PA')})
#         ).reset_index()
# 
#         if not pit_t1.empty:
#             team_era_now = pit_t1.groupby(['Year', 'Team']).apply(
#                 lambda x: pd.Series({'ERA': get_weighted_average(x, 'ERA', 'IP')})
#             ).reset_index()
#             team_stats = pd.merge(team_ops_now, team_era_now, on=['Year', 'Team'], how='left')
#         else:
#             team_stats = team_ops_now
# 
#         if 'ERA' in team_stats.columns and not team_stats.empty:
#             avg_era = team_stats['ERA'].mean()
#             avg_ops = team_stats['OPS'].mean()
# 
#             fig_quad = px.scatter(
#                 team_stats, x='ERA', y='OPS', color='Team',
#                 text='Year', size=[15]*len(team_stats), hover_name='Team'
#             )
#             fig_quad.add_vline(x=avg_era, line_dash="dash", line_color="gray", annotation_text="å¹³å‡ERA")
#             fig_quad.add_hline(y=avg_ops, line_dash="dash", line_color="gray", annotation_text="å¹³å‡OPS")
#             fig_quad.update_layout(xaxis=dict(autorange="reversed"))
# 
#             if len(t1_years) == 1:
#                 fig_quad.update_layout(title=f"{t1_years[0]} å¹´è³½å­£æˆ°åŠ›åˆ†ä½ˆ")
# 
#             st.plotly_chart(fig_quad, use_container_width=True)
#         else:
#             st.info("è«‹é¸æ“‡å¹´ä»½ä»¥é¡¯ç¤ºè³‡æ–™")
# 
# # Tab 2: æ‰“æ“Šæ’è¡Œ
# with tab2:
#     st.header("æ‰“æ“Šæ•¸æ“šæ’è¡Œæ¦œ")
# 
#     max_pa_val = int(df_bat['PA'].max()) if not df_bat.empty else 100
#     min_pa = st.slider("æœ€å°‘æ‰“å¸­æ•¸ (PA)", 0, max_pa_val, 50, key="t2_slider")
# 
#     bat_display = df_bat[df_bat['PA'] >= min_pa].sort_values('OPS', ascending=False)
# 
#     col1, col2 = st.columns([2, 1])
#     with col1:
#         st.subheader("ğŸ’¥ å¼·æ‰“è€…åˆ†ä½ˆ (PA vs OPS)")
#         fig = px.scatter(bat_display, x='PA', y='OPS', color='Team', hover_name='Name', size='HR')
#         if not bat_display.empty:
#             fig.add_hline(y=bat_display['OPS'].mean(), line_dash="dash", annotation_text="å¹³å‡")
#         st.plotly_chart(fig, use_container_width=True)
# 
#     with col2:
#         st.subheader("ğŸ“Š æ’è¡Œæ¦œ")
#         st.dataframe(
#             bat_display[['Name', 'Team', 'OPS', 'AVG', 'HR', 'SB', 'Year']],
#             column_config={
#                 "OPS": st.column_config.ProgressColumn("OPS", min_value=0, max_value=1.5, format="%.3f"),
#                 "AVG": st.column_config.NumberColumn("AVG", format="%.3f"),
#                 "Year": st.column_config.NumberColumn("å¹´ä»½", format="%d")
#             },
#             height=500,
#             hide_index=True
#         )
# 
# # Tab 3: æŠ•æ‰‹åˆ†æ
# with tab3:
#     st.subheader("ğŸ› ï¸ ç¯©é¸æ¢ä»¶")
# 
#     t3_teams = st.multiselect("é¸æ“‡çƒéšŠ", df_pit['Team'].unique(), default=df_pit['Team'].unique(), key="t3_team")
#     pit_t3 = df_pit[df_pit['Team'].isin(t3_teams)]
# 
#     st.divider()
#     st.header("æŠ•æ‰‹é€²éšæ•¸æ“š")
# 
#     if pit_t3.empty:
#         st.warning("âš ï¸ ç¯©é¸æ¢ä»¶ä¸‹ç„¡æŠ•æ‰‹è³‡æ–™")
#     else:
#         col1, col2 = st.columns([1, 1])
#         with col1:
#             st.subheader("ğŸ¯ ä¸‰æŒ¯ (SO) vs é˜²ç¦¦ç‡ (ERA)")
#             fig = px.scatter(pit_t3, x='SO', y='ERA', color='Team', hover_name='Name', size='IP')
#             fig.update_layout(yaxis=dict(range=[10, 0], title="ERA (é˜²ç¦¦ç‡)"))
#             st.plotly_chart(fig, use_container_width=True)
# 
#         with col2:
#             st.subheader("ğŸ•¸ï¸ æŠ•æ‰‹èƒ½åŠ›é›·é”åœ–")
#             df_radar = pit_t3[['Name', 'ERA', 'WHIP', 'SO', 'BB', 'IP']].copy()
# 
#             target = st.selectbox("é¸æ“‡æŠ•æ‰‹", df_radar['Name'].unique(), key="t3_select")
# 
#             if target:
#                 metrics = {'ERA': False, 'WHIP': False, 'SO': True, 'BB': False, 'IP': True}
#                 for col, higher_is_better in metrics.items():
#                     min_val = df_radar[col].min()
#                     max_val = df_radar[col].max()
#                     if max_val == min_val:
#                         df_radar[f'{col}_Score'] = 50
#                     else:
#                         if higher_is_better:
#                             df_radar[f'{col}_Score'] = (df_radar[col] - min_val) / (max_val - min_val) * 100
#                         else:
#                             df_radar[f'{col}_Score'] = (max_val - df_radar[col]) / (max_val - min_val) * 100
# 
#                 p_data = df_radar[df_radar['Name'] == target].iloc[0]
#                 avg_score = df_radar[[f'{k}_Score' for k in metrics.keys()]].mean()
#                 categories = list(metrics.keys())
#                 player_scores = [p_data[f'{c}_Score'] for c in categories]
#                 league_avg_scores = [avg_score[f'{c}_Score'] for c in categories]
# 
#                 fig = go.Figure()
#                 fig.add_trace(go.Scatterpolar(r=player_scores, theta=categories, fill='toself', name=p_data['Name'], line_color='blue'))
#                 fig.add_trace(go.Scatterpolar(r=league_avg_scores, theta=categories, fill='toself', name='è¯ç›Ÿå¹³å‡', line_color='gray', opacity=0.5))
#                 fig.update_layout(polar=dict(radialaxis=dict(visible=True, range=[0, 100])), title=f"èƒ½åŠ›å€¼è©•åˆ† (0-100)")
#                 st.plotly_chart(fig, use_container_width=True)
#                 st.caption("è¨»ï¼šåœ–è¡¨é¡¯ç¤ºçš„æ˜¯ã€ŒPRè©•åˆ†ã€(0~100)ï¼Œè¶Šå¤–åœˆä»£è¡¨è©²é …èƒ½åŠ›åœ¨è¯ç›Ÿä¸­è¶Šå¼·ã€‚")

"""### æ·±åº¦è«–å£‡

* wSB = SB * runSB + CS * runCS â€“ lgwSB * (1B + BB + HBP â€“ IBB)
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile pages/3_ğŸ’¬_æ·±åº¦è«–å£‡.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import plotly.express as px
# import plotly.graph_objects as go
# import sys
# import os
# 
# sys.path.append(os.path.abspath('.'))
# try:
#     from shared import styles
#     styles.apply_global_style()
# except ImportError:
#     pass
# 
# st.set_page_config(page_title="æ·±åº¦æ•¸æ“šè«–å£‡", layout="wide")
# 
# st.markdown("""
#     <style>
#     /* ç¢ºä¿æ¨£å¼æ­£ç¢º */
#     section[data-testid="stSidebar"] { background-color: #001844 !important; }
#     section[data-testid="stSidebar"] * { color: #FFFFFF !important; }
#     [data-testid="stMain"] h1, [data-testid="stMain"] h2, [data-testid="stMain"] h3 {
#         color: #000000 !important;
#         font-weight: bold !important;
#     }
#     </style>
# """, unsafe_allow_html=True)
# 
# st.title("ğŸ’¬ æ·±åº¦æ•¸æ“šè«–å£‡")
# st.markdown("### âš¾ Sabermetricsï¼šç”¨é€²éšæ•¸æ“šçœ‹æ£’çƒ")
# 
# @st.cache_data
# def load_data():
#     try:
#         df = pd.read_csv('baseball_data.csv')
#     except FileNotFoundError:
#         st.error("æ‰¾ä¸åˆ°è³‡æ–™æª”")
#         return pd.DataFrame()
# 
#     numeric_cols = [
#         'bat_PA', 'bat_AB', 'bat_R', 'bat_H', 'bat_2B', 'bat_3B', 'bat_HR',
#         'bat_SF', 'bat_SH', 'bat_BB', 'bat_IBB', 'bat_HBP',
#         'bat_SO', 'bat_SB', 'bat_CS', 'bat_GIDP',
#         'bat_AVG', 'bat_OPS'
#     ]
#     for c in numeric_cols:
#         if c in df.columns:
#             df[c] = pd.to_numeric(df[c], errors='coerce').fillna(0)
# 
#     # è¨ˆç®—
#     # ä¸€å£˜å®‰æ‰“ (1B) = H - 2B - 3B - HR
#     if 'bat_H' in df.columns and 'bat_2B' in df.columns:
#         df['bat_1B'] = df['bat_H'] - df['bat_2B'] - df['bat_3B'] - df['bat_HR']
#     else:
#         df['bat_1B'] = 0
# 
#     team_map = {
#         'çµ±ä¸€ç…': 'çµ±ä¸€7-ELEVEnç…', 'çµ±ä¸€': 'çµ±ä¸€7-ELEVEnç…',
#         'æ¡ƒçŒ¿': 'æ¨‚å¤©æ¡ƒçŒ¿', 'Lamigo': 'æ¨‚å¤©æ¡ƒçŒ¿', 'Rakuten': 'æ¨‚å¤©æ¡ƒçŒ¿',
#         'å…„å¼Ÿ': 'ä¸­ä¿¡å…„å¼Ÿ', 'å…„å¼Ÿè±¡': 'ä¸­ä¿¡å…„å¼Ÿ',
#         'å¯Œé‚¦': 'å¯Œé‚¦æ‚å°‡', 'ç¾©å¤§': 'å¯Œé‚¦æ‚å°‡',
#         'å‘³å…¨': 'å‘³å…¨é¾', 'å°é‹¼': 'å°é‹¼é›„é·¹'
#     }
#     target_teams = ['çµ±ä¸€7-ELEVEnç…', 'å°é‹¼é›„é·¹', 'ä¸­ä¿¡å…„å¼Ÿ', 'æ¨‚å¤©æ¡ƒçŒ¿', 'å‘³å…¨é¾', 'å¯Œé‚¦æ‚å°‡']
# 
#     cols_needed = [
#         'Name_clean', 'Team Name_x', 'Year',
#         'bat_PA', 'bat_AB', 'bat_R', 'bat_H', 'bat_1B', 'bat_BB', 'bat_HBP', 'bat_IBB',
#         'bat_SF', 'bat_AVG', 'bat_OPS', 'bat_SB', 'bat_CS'
#     ]
#     valid_cols = [c for c in cols_needed if c in df.columns]
# 
#     df_sorted = df[valid_cols].sort_values(by=['Year', 'bat_PA'], ascending=[False, False])
#     df_bat = df_sorted.drop_duplicates(subset=['Name_clean', 'Year'], keep='first')
# 
#     rename_dict = {
#         'Name_clean': 'Name', 'Team Name_x': 'Team',
#         'bat_OPS': 'OPS', 'bat_AVG': 'AVG',
#         'bat_SB': 'SB', 'bat_CS': 'CS', 'bat_PA': 'PA',
#         'bat_1B': '1B', 'bat_BB': 'BB', 'bat_HBP': 'HBP', 'bat_IBB': 'IBB',
#         'bat_R': 'R', 'bat_AB': 'AB', 'bat_H': 'H', 'bat_SF': 'SF'
#     }
#     df_bat = df_bat.rename(columns={k:v for k,v in rename_dict.items() if k in df_bat.columns})
# 
#     df_bat['Team'] = df_bat['Team'].replace(team_map)
#     df_bat = df_bat[df_bat['Team'].isin(target_teams)]
#     df_bat = df_bat[df_bat['PA'] > 0]
# 
#     return df_bat
# 
# df = load_data()
# 
# if df.empty:
#     st.stop()
# 
# # è­°é¡Œé¸æ“‡
# topic = st.radio(
#     "è«‹é¸æ“‡æƒ³è¦æ¢è¨çš„è­°é¡Œï¼š",
#     ["ğŸ“‰ è­°é¡Œä¸€ï¼šæ‰“æ“Šç‡ (AVG) æ˜¯ä¸æ˜¯éæ™‚äº†ï¼Ÿ", "ğŸƒ è­°é¡ŒäºŒï¼šç›œå£˜åƒ¹å€¼ (wSB) çš„æ‡‰ç”¨"],
#     horizontal=True
# )
# 
# st.divider()
# 
# # è­°é¡Œä¸€ï¼šæ‰“æ“Šç‡ vs OPS
# if "è­°é¡Œä¸€" in topic:
#     st.header("ğŸ“‰ æ‰“æ“Šç‡ (AVG) vs æ•´é«”æ”»æ“ŠæŒ‡æ•¸ (OPS)")
#     st.markdown("""
#     **å‚³çµ±è§€é»**ï¼šæ‰“æ“Šç‡ (AVG) æ˜¯è¡¡é‡æ‰“è€…å¥½å£çš„æœ€é‡è¦æŒ‡æ¨™ã€‚
#     **æ•¸æ“šè§€é»**ï¼šæ‰“æ“Šç‡å¿½ç•¥äº†ã€Œé¸çƒçœ¼ (ä¿é€)ã€å’Œã€Œé•·æ‰“èƒ½åŠ› (å…¨å£˜æ‰“)ã€ï¼Œæ‰“æ“Šç‡é«˜çš„çƒå“¡è²¢ç»åº¦å¯èƒ½ä¸å¦‚æ‰“æ“Šç‡ä½è€…ã€‚
#     """)
# 
#     col1, col2 = st.columns(2)
#     sel_year = col1.selectbox("é¸æ“‡å¹´ä»½", sorted(df['Year'].unique(), reverse=True))
#     min_pa = col2.slider("éæ¿¾ï¼šæœ€å°‘æ‰“å¸­æ•¸ (PA)", 0, 500, 100)
# 
#     df_topic1 = df[(df['Year'] == sel_year) & (df['PA'] >= min_pa)].copy()
# 
#     if not df_topic1.empty:
#         corr = df_topic1['AVG'].corr(df_topic1['OPS'])
#         st.info(f"ğŸ’¡ **æ•¸æ“šç™¼ç¾**ï¼šåœ¨ {sel_year} å¹´ï¼Œæ‰“æ“Šç‡èˆ‡ OPS çš„ç›¸é—œä¿‚æ•¸ç‚º **{corr:.2f}**ã€‚")
# 
#         fig = px.scatter(
#             df_topic1, x='AVG', y='OPS',
#             color='Team', size='PA', hover_name='Name',
#             text='Name',
#             title=f"{sel_year} å¹´æ‰“è€…åˆ†ä½ˆï¼šAVG vs OPS"
#         )
#         avg_mean = df_topic1['AVG'].mean()
#         ops_mean = df_topic1['OPS'].mean()
#         fig.add_vline(x=avg_mean, line_dash="dash", line_color="gray", annotation_text="å¹³å‡AVG")
#         fig.add_hline(y=ops_mean, line_dash="dash", line_color="gray", annotation_text="å¹³å‡OPS")
#         st.plotly_chart(fig, use_container_width=True)
#     else:
#         st.warning("æ­¤æ¢ä»¶ä¸‹ç„¡è³‡æ–™ã€‚")
# 
# # è­°é¡ŒäºŒï¼šç›œå£˜é‹ç”¨
# elif "è­°é¡ŒäºŒ" in topic:
#     st.header("ğŸƒ ç›œå£˜åˆ†æ")
# 
#     st.markdown("""
#     æˆ‘å€‘æ¡ç”¨ **FanGraphs** çš„ **wSB** å…¬å¼ä¾†è¨ˆç®—ç›œå£˜å°çƒéšŠçš„çœŸå¯¦å¾—åˆ†è²¢ç»ã€‚
# 
#     $$
#     wSB = (SB \\times runSB) + (CS \\times runCS) - (lgwSB \\times (1B + BB + HBP - IBB))
#     $$
# 
#     * **runSB (0.2)**ï¼šç›œå£˜æˆåŠŸçš„å¾—åˆ†æœŸæœ›å€¼ã€‚
#     * **runCS (ç´„ -0.4)**ï¼šç›œå£˜å¤±æ•—çš„æ‰£åˆ†ï¼Œæ ¹æ“šç•¶å¹´åº¦çš„å¾—åˆ†ç’°å¢ƒå‹•æ…‹è¨ˆç®—ã€‚
#     * **lgwSB**ï¼šè¯ç›Ÿå¹³å‡å€¼ï¼Œç”¨ä¾†æ‰£é™¤ã€Œå¹³å‡è·‘è€…åœ¨åŒæ¨£ä¸Šå£˜æ©Ÿæœƒä¸‹æ‡‰æœ‰çš„è²¢ç»ã€ã€‚
#     """)
# 
#     # ç¯©é¸
#     col1, col2 = st.columns(2)
#     sel_years = col1.multiselect("é¸æ“‡å¹´ä»½", sorted(df['Year'].unique(), reverse=True), default=[2024, 2025] if 2024 in df['Year'].unique() else [df['Year'].max()])
#     min_sb_attempt = col2.slider("éæ¿¾ï¼šæœ€å°‘å˜—è©¦ç›œå£˜æ¬¡æ•¸ (SB+CS)", 0, 30, 5)
# 
#     df_topic2 = df[df['Year'].isin(sel_years)].copy()
# 
#     # è¨ˆç®— wSB åƒæ•¸
#     if not df_topic2.empty:
#         # è¨ˆç®—è¯ç›Ÿç¸½å’Œ
#         lg_R = df_topic2['R'].sum()
#         # ä¼°ç®— Outs (Outs = AB - H + CS + SF)
#         lg_Outs = (df_topic2['AB'].sum() - df_topic2['H'].sum()) + df_topic2['CS'].sum() + df_topic2['SF'].sum()
#         if lg_Outs == 0: lg_Outs = 1
# 
#         # å‹•æ…‹è¨ˆç®— runCS (FanGraphs å…¬å¼: 2 * R/Outs + 0.075)
#         runs_per_out = lg_R / lg_Outs
#         runSB = 0.2
#         runCS = -1 * (2 * runs_per_out + 0.075)
# 
#         # è¨ˆç®— lgwSB
#         lg_SB = df_topic2['SB'].sum()
#         lg_CS = df_topic2['CS'].sum()
#         # ä¸Šå£˜æ©Ÿæœƒ (Singles + BB + HBP - IBB)
#         lg_1B = df_topic2['1B'].sum()
#         lg_BB = df_topic2['BB'].sum()
#         lg_HBP = df_topic2['HBP'].sum()
#         lg_IBB = df_topic2['IBB'].sum()
# 
#         lg_opportunities = lg_1B + lg_BB + lg_HBP - lg_IBB
#         if lg_opportunities == 0: lg_opportunities = 1
# 
#         lgwSB = (lg_SB * runSB + lg_CS * runCS) / lg_opportunities
# 
#         def calculate_wSB(row):
#             opportunities = row['1B'] + row['BB'] + row['HBP'] - row['IBB']
#             # wSB
#             val = (row['SB'] * runSB) + (row['CS'] * runCS) - (lgwSB * opportunities)
#             return val
# 
#         df_topic2['wSB'] = df_topic2.apply(calculate_wSB, axis=1)
#         df_topic2['Attempt'] = df_topic2['SB'] + df_topic2['CS']
# 
#         # éæ¿¾
#         df_filtered = df_topic2[df_topic2['Attempt'] >= min_sb_attempt].copy()
#         df_filtered['SB_Rate'] = df_filtered.apply(lambda x: (x['SB']/x['Attempt']*100) if x['Attempt']>0 else 0, axis=1)
# 
#         st.info(f"ğŸ“Š **æœ¬æœŸåƒæ•¸**ï¼šrunCS (å¤±æ•—æ‰£åˆ†) = **{runCS:.3f}** (ç´„ç‚ºæˆåŠŸçš„ {abs(runCS/runSB):.1f} å€ä»£åƒ¹)")
# 
#         # è¡¨ 1: wSB æ’è¡Œæ¦œ
#         st.subheader("ğŸ† wSB æ’è¡Œæ¦œï¼šèª°æ˜¯çœŸæ­£çš„ç›œå£˜è²¢ç»ç‹ï¼Ÿ")
#         st.caption("wSB > 0 ä»£è¡¨æ¯”è¯ç›Ÿå¹³å‡è·‘è€…è²¢ç»æ›´å¤šåˆ†æ•¸ï¼›wSB < 0 ä»£è¡¨æ‹–ç´¯çƒéšŠã€‚")
# 
#         top_n = 10
#         df_rank = df_filtered.sort_values('wSB', ascending=True).tail(top_n)
#         df_bottom = df_filtered.sort_values('wSB', ascending=True).head(5)
#         df_chart = pd.concat([df_bottom, df_rank]).drop_duplicates().sort_values('wSB')
# 
#         colors = ['red' if x < 0 else '#2E5090' for x in df_chart['wSB']]
# 
#         fig = go.Figure()
#         fig.add_trace(go.Bar(
#             y=df_chart['Name'], x=df_chart['wSB'],
#             orientation='h', marker_color=colors,
#             text=df_chart['wSB'].apply(lambda x: f"{x:.2f}"),
#             textposition='auto',
#             hovertemplate="<b>%{y}</b><br>SB: %{customdata[0]}<br>CS: %{customdata[1]}<br>wSB: %{x:.2f}<extra></extra>",
#             customdata=df_chart[['SB', 'CS']]
#         ))
#         fig.update_layout(title="Weighted Stolen Base Runs (wSB)", xaxis_title="wSB (åˆ†æ•¸è²¢ç»)", height=600)
#         st.plotly_chart(fig, use_container_width=True)
# 
#         # è¡¨ 2ï¼šé«˜æˆåŠŸç‡ä¸ä»£è¡¨é«˜è²¢ç»
#         st.subheader("ğŸ“‰ æˆåŠŸç‡ vs wSBï¼šé«˜æˆåŠŸç‡ä¸ä»£è¡¨é«˜è²¢ç»")
#         fig2 = px.scatter(
#             df_filtered, x='SB_Rate', y='wSB',
#             color='Team', size='Attempt', hover_name='Name',
#             text='Name',
#             labels={'SB_Rate': 'ç›œå£˜æˆåŠŸç‡ (%)', 'wSB': 'wSB (å¾—åˆ†è²¢ç»)'},
#             title="æœ‰äº›çƒå“¡æˆåŠŸç‡é«˜(å³é‚Š)ï¼Œä½†å› ç‚ºè·‘å¾—å°‘æˆ–æ©Ÿæœƒæˆæœ¬é«˜ï¼ŒwSB å…¶å¯¦ä¸é«˜"
#         )
#         fig2.add_hline(y=0, line_dash="solid", line_color="gray")
#         fig2.add_vline(x=75, line_dash="dash", line_color="red", annotation_text="75% åŠæ ¼ç·š")
#         st.plotly_chart(fig2, use_container_width=True)
# 
#         # çµè«–
#         best = df_filtered.loc[df_filtered['wSB'].idxmax()]
#         worst = df_filtered.loc[df_filtered['wSB'].idxmin()]
# 
#         st.success(f"ğŸ¥‡ **æœ€ä½³è·‘è€…**ï¼š**{best['Name']}** (wSB {best['wSB']:.2f})ã€‚ä»–åœ¨æ‰£é™¤å¤±æ•—é¢¨éšªèˆ‡æ©Ÿæœƒæˆæœ¬å¾Œï¼Œä¾ç„¶ç‚ºçƒéšŠå‰µé€ äº†é¡¯è‘—åƒ¹å€¼ã€‚")
#         if worst['wSB'] < 0:
#             st.error(f"âš ï¸ **è² åˆ†è·‘è€…**ï¼š**{worst['Name']}** (wSB {worst['wSB']:.2f})ã€‚é›–ç„¶ä»–å¯èƒ½è·‘äº†ä¸å°‘ï¼Œä½†ç›¸å°æ–¼è¯ç›Ÿå¹³å‡ï¼Œä»–çš„è·‘å£˜ç­–ç•¥å…¶å¯¦æ˜¯åœ¨æ¸›å°‘çƒéšŠå¾—åˆ†æœŸæœ›å€¼ã€‚")
# 
#     else:
#         st.warning("âš ï¸ æ­¤æ¢ä»¶ä¸‹ç„¡è³‡æ–™")

"""### AI_çƒæ¢å°è©±"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile pages/4_ğŸ§‘â€ğŸ’¼_AI_çƒæ¢å°è©±.py
# import streamlit as st
# import os
# import requests
# import time
# from google import genai
# from google.genai import types
# from shared.styles import apply_global_style
# 
# apply_global_style()
# st.header("ğŸ§‘â€ğŸ’¼ AI å°è©±ç³»çµ±")
# 
# gemini_key = "AIzaSyBN5FU3Wk-DcFeRwINM9F6jBLwmS94chng"
# client = genai.Client(api_key=gemini_key)
# 
# GITHUB_USER = "ChewyChloe"
# GITHUB_REPO = "cpbl-project"
# GITHUB_FOLDER = "AI_RAG"
# GITHUB_API_URL = f"https://api.github.com/repos/{GITHUB_USER}/{GITHUB_REPO}/contents/{GITHUB_FOLDER}"
# TARGET_STORE_NAME = "CPBL_Scout_Knowledge_v6"
# 
# @st.cache_resource(show_spinner="åŒæ­¥ GitHub çŸ¥è­˜åº«")
# def auto_initialize_rag(_client):
#     store = None
# 
#     try:
#         for s in _client.file_search_stores.list():
#             if s.display_name == TARGET_STORE_NAME:
#                 store = s
#                 break
#     except Exception:
#         pass
# 
#     if not store:
#         try:
#             store = _client.file_search_stores.create(
#                 config={'display_name': TARGET_STORE_NAME}
#             )
#         except Exception as e:
#             print(f"å»ºç«‹ Store å¤±æ•—: {e}")
#             return None
# 
#     existing_files = []
#     try:
#         pager = _client.file_search_stores.list_files(file_search_store_name=store.name)
#         existing_files = list(pager)
#     except:
#         pass
# 
#     if len(existing_files) == 0:
#         try:
#             res = requests.get(GITHUB_API_URL)
#             if res.status_code == 200:
#                 files_metadata = res.json()
#                 for i, file_info in enumerate(files_metadata):
#                     original_name = file_info['name']
#                     lower_name = original_name.lower()
# 
#                     if lower_name.endswith(('.pdf', '.txt', '.docx')):
#                         f_res = requests.get(file_info['download_url'])
# 
#                         if f_res.status_code == 200:
#                             safe_ext = ".pdf" if ".pdf" in lower_name else ".txt" if ".txt" in lower_name else ".docx"
#                             safe_temp_name = f"temp_doc_{i}{safe_ext}"
# 
#                             with open(safe_temp_name, "wb") as f:
#                                 f.write(f_res.content)
# 
#                             if os.path.getsize(safe_temp_name) > 0:
#                                 mime_type = "application/pdf"
#                                 if safe_ext == ".txt": mime_type = "text/plain"
#                                 elif safe_ext == ".docx": mime_type = "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
# 
#                                 try:
#                                     _client.file_search_stores.upload_to_file_search_store(
#                                         file=safe_temp_name,
#                                         file_search_store_name=store.name,
#                                         config={
#                                             'display_name': original_name,
#                                             'mime_type': mime_type
#                                         }
#                                     )
#                                     time.sleep(1)
#                                 except Exception as e:
#                                     print(f"ä¸Šå‚³å¤±æ•—: {e}")
# 
#                             if os.path.exists(safe_temp_name):
#                                 os.remove(safe_temp_name)
#         except Exception as e:
#             print(f"GitHub åŒæ­¥éŒ¯èª¤: {e}")
# 
#     return store.name if store else None
# 
# # åˆå§‹åŒ–
# store_name = auto_initialize_rag(client)
# 
# if not store_name:
#     st.error("âš ï¸ çŸ¥è­˜åº«åˆå§‹åŒ–å¤±æ•—ã€‚")
#     st.stop()
# 
# # å°è©±ä»‹é¢
# if "messages" not in st.session_state:
#     st.session_state.messages = []
# 
# for msg in st.session_state.messages:
#     with st.chat_message(msg["role"]):
#         st.markdown(msg["content"])
# 
# if prompt := st.chat_input("è«‹æ•™å°ˆæ¥­çƒæ¢åˆ†æ..."):
#     st.session_state.messages.append({"role": "user", "content": prompt})
#     with st.chat_message("user"):
#         st.markdown(prompt)
# 
#     with st.chat_message("assistant"):
#         with st.spinner("æ€è€ƒä¸­..."):
#             try:
#                 response = client.models.generate_content(
#                     model="gemini-2.5-flash",
#                     contents=prompt,
#                     config={
#                         "tools": [{
#                             "file_search": {
#                                 "file_search_store_names": [store_name]
#                             }
#                         }],
#                         "system_instruction": """
#                         ä½ æ˜¯ä¸€ä½å°ˆæ¥­çš„æ£’çƒç ”ç©¶å“¡ã€‚
#                         1. ç•¶ä½¿ç”¨è€…å•åˆ°å…·é«”æ•¸æ“šæˆ–çƒæ¢å ±å‘Šæ™‚ï¼Œè«‹å„ªå…ˆåƒè€ƒã€ŒçŸ¥è­˜åº«ã€ä¸­çš„æª”æ¡ˆå›ç­”ã€‚
#                         2. å¦‚æœçŸ¥è­˜åº«ä¸­æ²’æœ‰ç›¸é—œè³‡è¨Šï¼Œæˆ–è€…ä½¿ç”¨è€…æ˜¯åœ¨å•ä¸€èˆ¬æ£’çƒè¦å‰‡ã€æ­·å²æˆ–é–’èŠï¼Œè«‹å–„ç”¨ä½ çš„ã€Œé€šç”¨æ£’çƒçŸ¥è­˜ã€ç›´æ¥å›ç­”ã€‚
#                         3. å›ç­”æ™‚è«‹ä¿æŒå°ˆæ¥­ã€å®¢è§€ï¼Œçµ•å°ä¸å¯æåŠ"è³‡æ–™åº«"ã€"æ ¹æ“šæˆ‘å€‘æ‰‹é‚Šçš„è³‡æ–™"æˆ–"æ ¹æ“š..."ã€‚
#                         4. èªæ°£è¼•é¬†ä¸åš´è‚…
#                         5. åå­—ï¼šBrian
#                         """
#                     }
#                 )
#                 st.markdown(response.text)
#                 st.session_state.messages.append({"role": "assistant", "content": response.text})
# 
#             except Exception as e:
#                 st.error(f"ç”Ÿæˆå›æ‡‰æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")

"""### æˆå“¡å¡ç‰Œ

import google.generativeai as genai
import time
from google.colab import files

MY_API_KEY = "AIzaSyBN5FU3Wk-DcFeRwINM9F6jBLwmS94chng"

genai.configure(api_key=MY_API_KEY)
model = genai.GenerativeModel('gemini-2.5-flash')

df = pd.read_csv("https://raw.githubusercontent.com/ChewyChloe/cpbl-project/d58371c954f80fac88be0eaf55943453dfe3ee0a/baseball_data.csv")

required_cols = ['bat_AVG', 'bat_OPS', 'bat_HR', 'pit_ERA', 'pit_W', 'pit_SO', 'pit_WHIP', 'pit_IP']
for c in required_cols:
    if c not in df.columns: df[c] = 0
    df[c] = pd.to_numeric(df[c], errors='coerce').fillna(0)

TARGET_PLAYERS = ['æ±Ÿå¤å®‡', 'æ—ç«‹', 'é™³å† å®‡', 'é™³å‚‘æ†²']
commentaries = {}

for player_name in TARGET_PLAYERS:
    p_rows = df[df['Name_clean'] == player_name].sort_values('Year', ascending=False)

    if p_rows.empty:
        print(f"âš ï¸ æ‰¾ä¸åˆ° {player_name}")
        continue

    data = p_rows.iloc[0]
    is_pitcher = data.get('pit_IP', 0) > 0

    if is_pitcher:
        stats = f"é˜²ç¦¦ç‡ {data.get('pit_ERA', 0):.2f}, å‹æŠ• {int(data.get('pit_W', 0))}, WHIP {data.get('pit_WHIP', 0):.2f}"
        role = "æŠ•æ‰‹"
    else:
        stats = f"æ‰“æ“Šç‡ {data.get('bat_AVG', 0):.3f}, OPS {data.get('bat_OPS', 0):.3f}, å…¨å£˜æ‰“ {int(data.get('bat_HR', 0))}"
        role = "æ‰“è€…"

    prompt = f"è«‹ç”¨å°ˆæ¥­æ£’çƒçƒè©•å£å»ï¼Œé‡å°ä¸­è¯è·æ£’{role}ã€Œ{player_name}ã€å¯«ä¸€æ®µç´„80å­—çš„çŸ­è©•ã€‚é‡é»æ•¸æ“šï¼š{stats}ã€‚é¢¨æ ¼è¦å°ˆæ¥­ã€‚"

    try:
        response = model.generate_content(prompt)
        comment = response.text.strip()
        commentaries[player_name] = comment
        print(f"{player_name} å®Œæˆ")
    except Exception as e:
        print(f"{player_name} å¤±æ•—: {e}")

    time.sleep(2)

filename = "player_commentaries.json"
with open(filename, "w", encoding="utf-8") as f:
    json.dump(commentaries, f, ensure_ascii=False, indent=4)
files.download(filename)
"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile pages/5_âš¾_çƒå“¡å¡ç‰Œ.py
# import streamlit as st
# import pandas as pd
# import plotly.graph_objects as go
# import requests
# import json
# 
# st.set_page_config(page_title="çƒå“¡ä»‹é¢", page_icon="ğŸƒ", layout="wide")
# 
# JSON_URL = "https://raw.githubusercontent.com/ChewyChloe/cpbl-project/refs/heads/main/player_commentary.json"
# DATA_URL = "https://raw.githubusercontent.com/ChewyChloe/cpbl-project/d58371c954f80fac88be0eaf55943453dfe3ee0a/baseball_data.csv"
# 
# # çƒå“¡åå–®ã€ç…§ç‰‡
# TARGET_PLAYERS = ['æ±Ÿå¤å®‡', 'æ—ç«‹', 'é™³å† å®‡', 'é™³å‚‘æ†²']
# PLAYER_PHOTOS = {
#     'æ±Ÿå¤å®‡': 'https://imgcdn.cna.com.tw/www/WebPhotos/800/20241001/824x1024_wmkn_0_C20241001000234.jpg',
#     'æ—ç«‹': 'https://img.ltn.com.tw/Upload/sports/page/800/2023/12/22/120.jpg',
#     'é™³å† å®‡': 'https://hips.hearstapps.com/hmg-prod/images/pitcher-chen-kuan-yu-of-chinese-taipei-reacts-at-the-end-of-news-photo-1732522777.jpg',
#     'é™³å‚‘æ†²': 'https://img.ltn.com.tw/Upload/sports/page/800/2025/06/04/121.jpg'
# }
# TEAM_FIX = {
#     'æ±Ÿå¤å®‡': 'ä¸­ä¿¡å…„å¼Ÿ',
#     'æ—ç«‹': 'æ¨‚å¤©æ¡ƒçŒ¿',
#     'é™³å† å®‡': 'æ¨‚å¤©æ¡ƒçŒ¿',
#     'é™³å‚‘æ†²': 'çµ±ä¸€ç…'
# }
# 
# @st.cache_data
# def load_data():
#     try:
#         df = pd.read_csv(DATA_URL)
#         numeric_cols = ['bat_AVG', 'bat_OPS', 'bat_HR', 'bat_SB', 'bat_RBI',
#                         'pit_ERA', 'pit_W', 'pit_SO', 'pit_WHIP', 'pit_IP']
#         for c in numeric_cols:
#             if c in df.columns:
#                 df[c] = pd.to_numeric(df[c], errors='coerce').fillna(0)
#     except Exception as e:
#         return pd.DataFrame(), {}
# 
#     commentaries = {}
#     try:
#         response = requests.get(JSON_URL)
#         if response.status_code == 200:
#             commentaries = response.json()
#         else:
#             alt_url = JSON_URL.replace("/refs/heads/main/", "/main/")
#             response = requests.get(alt_url)
#             if response.status_code == 200:
#                 commentaries = response.json()
#     except Exception as e:
#         pass
# 
#     return df, commentaries
# 
# # é›·é”åœ–
# def create_radar_chart(player_data):
#     player_name = player_data['Name_clean']
#     is_pitcher = player_data.get('pit_IP', 0) > 0
# 
#     fig = go.Figure()
# 
#     if is_pitcher:
#         categories = ['å‹æŠ•', 'å¥ªä¸‰æŒ¯', 'å±€æ•¸', 'é˜²ç¦¦ç‡', 'WHIP']
#         real_values = [
#             player_data.get('pit_W', 0), player_data.get('pit_SO', 0), player_data.get('pit_IP', 0),
#             player_data.get('pit_ERA', 0), player_data.get('pit_WHIP', 0)
#         ]
#         plot_values = [
#             min(real_values[0] * 5, 100), min(real_values[1] * 0.5, 100), min(real_values[2] * 0.5, 100),
#             max((5 - real_values[3]) * 20, 0), max((2 - real_values[4]) * 50, 0)
#         ]
#     else:
#         categories = ['æ‰“æ“Šç‡', 'OPS', 'å…¨å£˜æ‰“', 'æ‰“é»', 'ç›œå£˜']
#         real_values = [
#             player_data.get('bat_AVG', 0), player_data.get('bat_OPS', 0), player_data.get('bat_HR', 0),
#             player_data.get('bat_RBI', 0), player_data.get('bat_SB', 0)
#         ]
#         plot_values = [
#             min(real_values[0] * 300, 100), min(real_values[1] * 100, 100), min(real_values[2] * 4, 100),
#             min(real_values[3] * 1, 100), min(real_values[4] * 3, 100)
#         ]
# 
#     fig.add_trace(go.Scatterpolar(
#         r=plot_values,
#         theta=categories,
#         fill='toself',
#         name=player_name,
#         line_color='#FFD700',
#         fillcolor='rgba(255, 215, 0, 0.3)',
#         hovertemplate="%{theta}: <b>%{text}</b><extra></extra>",
#         text=[f"{v:.2f}" if isinstance(v, float) else v for v in real_values]
#     ))
# 
#     fig.update_layout(
#         polar=dict(
#             radialaxis=dict(
#                 visible=True,
#                 range=[0, 100],
#                 showticklabels=True,
#                 tickfont=dict(color='rgba(255,255,255,0.7)', size=9),
#                 gridcolor='rgba(255, 255, 255, 0.2)',
#                 linecolor='rgba(255, 255, 255, 0.2)'
#             ),
#             angularaxis=dict(
#                 visible=True,
#                 tickfont=dict(color='#FFD700', size=14, weight='bold'),
#                 gridcolor='rgba(255, 255, 255, 0.2)'
#             ),
#             bgcolor='rgba(0,0,0,0)'
#         ),
#         showlegend=False,
#         height=300,
#         margin=dict(t=40, b=20, l=40, r=40),
#         paper_bgcolor='rgba(0,0,0,0)',
#         plot_bgcolor='rgba(0,0,0,0)',
#         font=dict(color='white')
#     )
#     return fig
# 
# # ä½ˆå±€
# st.title("ğŸƒçƒå“¡ä»‹ç´¹å¡ç‰Œ")
# 
# st.markdown("""
# <style>
# div[data-testid="stVerticalBlockBorderWrapper"] {
#     background: linear-gradient(145deg, #1e1e2f, #2a2a40);
#     border: 2px solid #FFD700 !important;
#     border-radius: 15px;
#     box-shadow: 0 8px 16px rgba(0,0,0,0.3);
# }
# div[data-testid="stVerticalBlockBorderWrapper"] * {
#     color: white !important;
# }
# .stTabs [data-baseweb="tab-list"] { background-color: transparent; }
# .stTabs [aria-selected="true"] { color: #FFD700 !important; font-weight: bold; }
# </style>
# """, unsafe_allow_html=True)
# 
# df, commentaries = load_data()
# 
# if df.empty:
#     st.error("âš ï¸ ç„¡æ³•è®€å–è³‡æ–™")
#     st.stop()
# 
# df_players = df[df['Name_clean'].isin(TARGET_PLAYERS)].copy()
# df_players = df_players.sort_values('Year', ascending=False).drop_duplicates(subset='Name_clean', keep='first')
# 
# st.divider()
# 
# cols = st.columns(2) + st.columns(2)
# 
# count = 0
# for i, player_name in enumerate(TARGET_PLAYERS):
#     if i >= 4: break
# 
#     col = cols[i]
#     rows = df_players[df_players['Name_clean'] == player_name]
# 
#     if rows.empty:
#         col.warning(f"ç¼ºå¤± {player_name}")
#         continue
# 
#     data = rows.iloc[0]
#     comment = commentaries.get(player_name,)
#     fig = create_radar_chart(data)
#     photo = PLAYER_PHOTOS.get(player_name, "")
# 
#     # åˆ¤æ–·èº«åˆ†
#     role = "æŠ•æ‰‹" if data.get('pit_IP', 0) > 0 else "æ‰“æ“Šæ‰‹"
# 
#     # åˆ¤æ–·éšŠå
#     team_name = data.get('Team Name_x')
#     if pd.isna(team_name) or str(team_name).lower() == 'nan':
#         team_name = TEAM_FIX.get(player_name, "CPBL")
# 
#     with col:
#         with st.container(height=600, border=True):
#             st.subheader(player_name)
#             st.caption(f"{team_name} | {role}")
# 
#             t1, t2 = st.tabs(["ğŸ“· ç…§ç‰‡", "ğŸ“Š åˆ†æ"])
# 
#             with t1:
#                 if photo: st.image(photo, use_container_width=True)
#                 else: st.info("ç„¡ç…§ç‰‡")
# 
#             with t2:
#                 st.markdown("#### ğŸ§ AI çƒè©•")
#                 st.info(comment)
#                 st.markdown("#### ğ–£  èƒ½åŠ›é›·é”")
#                 st.plotly_chart(fig, use_container_width=True, config={'displayModeBar': False})
#     count += 1
# 
# if count == 0:
#     st.warning("æ²’æœ‰é¡¯ç¤ºä»»ä½•å¡ç‰Œ")

"""### äº’å‹•ä»‹é¢"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile pages/6_ğŸ‘¾_æ£’çƒå°äº’å‹•.py
# import time
# from io import BytesIO
# 
# import requests
# import streamlit as st
# from PIL import Image
# from streamlit_image_coordinates import streamlit_image_coordinates
# 
# st.set_page_config(page_title="å°äº’å‹•", page_icon="ğŸ‘¾", layout="wide")
# 
# BASE_URL = "https://raw.githubusercontent.com/ChewyChloe/cpbl-project/main/game"
# 
# ASSET_VER = "2025-12-24-1"
# 
# def v(url: str) -> str:
#     return f"{url}?v={ASSET_VER}"
# 
# IMAGES = {
#     "BG": v(f"{BASE_URL}/playground.png"),
#     "P": v(f"{BASE_URL}/P.png"),
#     "C": v(f"{BASE_URL}/C.png"),
#     "1B": v(f"{BASE_URL}/1B.png"),
#     "2B": v(f"{BASE_URL}/2B.png"),
#     "3B": v(f"{BASE_URL}/3B.png"),
#     "SS": v(f"{BASE_URL}/SS.png"),
#     "LF": v(f"{BASE_URL}/LF.png"),
#     "CF": v(f"{BASE_URL}/CF.png"),
#     "RF": v(f"{BASE_URL}/RF.png"),
#     "Batter": v(f"{BASE_URL}/batter.png"),
# }
# 
# players_data = {
#     "P": {"name": "ç‹ç‰ŒæŠ•æ‰‹", "desc": "æˆ‘æ˜¯çƒå ´ä¸Šçš„ç¨è£è€…ï¼ŒæŒæ§æ¯”è³½ç¯€å¥ï¼"},
#     "C": {"name": "éµå£æ•æ‰‹", "desc": "æˆ‘æ˜¯å ´ä¸Šçš„æŒ‡æ®å®˜ï¼Œæƒ³å¾—åˆ†å…ˆéæˆ‘é€™é—œï¼"},
#     "1B": {"name": "ä¸€å£˜å¤§ç ²", "desc": "ä¸ç®¡æ˜¯æ¥çƒé‚„æ˜¯æ‰“æ“Šï¼Œæˆ‘éƒ½æ˜¯æœ€ç©©å®šçš„å­˜åœ¨ã€‚"},
#     "2B": {"name": "éˆæ´»äºŒå£˜", "desc": "é›™æ®ºå®ˆå‚™æ˜¯æˆ‘çš„æ‹¿æ‰‹å¥½æˆ²ï¼Œèª°éƒ½åˆ¥æƒ³ç©¿è¶Šä¸­ç·šï¼"},
#     "3B": {"name": "ç†±è§’ä¸‰å£˜", "desc": "å¼·è¥²çƒä¾†å§ï¼æˆ‘çš„åæ‡‰ç¥ç¶“å¯æ˜¯å…¨éšŠæœ€å¿«çš„ã€‚"},
#     "SS": {"name": "éŠæ“Šæ‰‹", "desc": "å…§é‡é˜²å®ˆæ ¸å¿ƒï¼Œå®ˆå‚™ç¯„åœç„¡æ¥µé™ï¼"},
#     "LF": {"name": "å·¦å¤–é‡æ‰‹", "desc": "é€™çƒé£›å¾—å¥½é ...ä½†æˆ‘ä¸€å®šæ¥å¾—åˆ°ï¼"},
#     "CF": {"name": "ä¸­å¤–é‡æ‰‹", "desc": "æˆ‘æ˜¯å¤–é‡çš„éšŠé•·ï¼Œé€™ç‰‡è‰åœ°ç”±æˆ‘å®ˆè­·ã€‚"},
#     "RF": {"name": "å³å¤–é‡æ‰‹", "desc": "æƒ³è·‘ä¸‰å£˜ï¼Ÿå°å¿ƒæˆ‘çš„é•·å‚³ç‹™æ“Šï¼"},
#     "Batter": {"name": "æ‰“æ“Šè€…", "desc": "æˆ‘çš„å·¥ä½œåªæœ‰ä¸€å€‹ï¼šæŠŠé‚£é¡†å°ç™½çƒè½Ÿå‡ºå ´å¤–ï¼"},
# }
# 
# FIELD_W = 800
# FIELD_H = 600
# 
# # ä½ç½®
# PLACEMENTS = {
#     "P": {"top": 0.57, "left": 0.40, "w": 135, "h": 135},
#     "C": {"top": 0.80, "left": 0.42, "w": 120, "h": 120},
#     "Batter": {"top": 0.70, "left": 0.37, "w": 135, "h": 135},
#     "1B": {"top": 0.55, "left": 0.63, "w": 135, "h": 135},
#     "2B": {"top": 0.38, "left": 0.52, "w": 110, "h": 110},
#     "3B": {"top": 0.58, "left": 0.22, "w": 135, "h": 135},
#     "SS": {"top": 0.40, "left": 0.32, "w": 80, "h": 80},
#     "LF": {"top": 0.28, "left": 0.15, "w": 135, "h": 135},
#     "CF": {"top": 0.18, "left": 0.40, "w": 135, "h": 135},
#     "RF": {"top": 0.32, "left": 0.70, "w": 135, "h": 135},
# }
# 
# # å°è©±æ¡†ï¼‰
# st.markdown("""
# <style>
# @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
# 
# .stApp {
#     font-family: 'Courier New', monospace;
#     background-color: #202020;
# }
# 
# .rpg-box-container {
#     background-color: #000080;
#     border: 6px solid #ffffff;
#     padding: 5px;
#     box-shadow: 5px 5px 0px #000000;
#     margin-top: 16px;
# }
# .rpg-box-inner {
#     background-color: #000080;
#     border: 4px solid #000080;
#     padding: 18px;
#     color: white;
#     font-family: 'Press Start 2P', cursive !important;
#     line-height: 1.8;
#     font-size: 16px;
#     min-height: 120px;
# }
# .char-name-tag {
#     font-family: 'Press Start 2P', cursive !important;
#     background-color: #e0c050;
#     color: #000000;
#     padding: 5px 15px;
#     border: 3px solid #ffffff;
#     display: inline-block;
#     margin-bottom: -10px;
#     margin-left: 10px;
#     box-shadow: 3px 3px 0px #000000;
# }
# </style>
# """, unsafe_allow_html=True)
# 
# # é»æ“Šåˆ¤å®š
# @st.cache_data(show_spinner=False)
# def fetch_image(url: str, ver: str) -> Image.Image:
#     r = requests.get(url, timeout=20)
#     r.raise_for_status()
#     return Image.open(BytesIO(r.content)).convert("RGBA")
# 
# def build_map(selected_role: str | None):
#     bg = fetch_image(IMAGES["BG"], ASSET_VER).resize((FIELD_W, FIELD_H))
#     regions = {}
# 
#     for role, p in PLACEMENTS.items():
#         scale = 1.3 if role == selected_role else 1.0
#         w = int(p["w"] * scale)
#         h = int(p["h"] * scale)
# 
#         sprite = fetch_image(IMAGES[role], ASSET_VER).resize((w, h))
# 
#         x = int(p["left"] * FIELD_W)
#         y = int(p["top"] * FIELD_H)
# 
#         bg.alpha_composite(sprite, (x, y))
#         regions[role] = (x, y, x + w, y + h)
# 
#     return bg, regions
# 
# def detect_role(x: int, y: int, regions: dict) -> str | None:
#     for role, (x1, y1, x2, y2) in regions.items():
#         if x1 <= x <= x2 and y1 <= y <= y2:
#             return role
#     return None
# 
# # ç‹€æ…‹
# if "selected_role" not in st.session_state:
#     st.session_state.selected_role = None
# if "last_click" not in st.session_state:
#     st.session_state.last_click = None
# if "last_typed_role" not in st.session_state:
#     st.session_state.last_typed_role = None
# 
# st.title("ğŸ‘¾ åƒç´ æ£’çƒå ´")
# 
# left, right = st.columns([2.2, 1.0], vertical_alignment="top")
# 
# with left:
#     field_img, regions = build_map(st.session_state.selected_role)
#     clicked = streamlit_image_coordinates(field_img, width=FIELD_W)
# 
#     if clicked and "x" in clicked and "y" in clicked:
#         xy = (int(clicked["x"]), int(clicked["y"]))
#         if xy != st.session_state.last_click:
#             st.session_state.last_click = xy
#             st.session_state.selected_role = detect_role(xy[0], xy[1], regions)
#             if st.session_state.selected_role != st.session_state.last_typed_role:
#                 st.session_state.last_typed_role = None
# 
# with right:
#     role = st.session_state.selected_role
# 
#     if role:
#         data = players_data[role]
# 
#         st.image(IMAGES[role], width=180)
# 
#         st.markdown(f'<div class="char-name-tag">{data["name"]}</div>', unsafe_allow_html=True)
#         box = st.empty()
# 
#         if st.session_state.last_typed_role != role:
#             st.session_state.last_typed_role = role
#             text = ""
#             for ch in data["desc"]:
#                 text += ch
#                 box.markdown(f"""
#                 <div class="rpg-box-container">
#                     <div class="rpg-box-inner">{text}</div>
#                 </div>
#                 """, unsafe_allow_html=True)
#                 time.sleep(0.04)
#         else:
#             box.markdown(f"""
#             <div class="rpg-box-container">
#                 <div class="rpg-box-inner">{data["desc"]}</div>
#             </div>
#             """, unsafe_allow_html=True)
#     else:
#         st.markdown("""
#         <div class="rpg-box-container">
#             <div class="rpg-box-inner">
#                 ï¼ˆé»æ“Šçƒå ´ä¸Šçš„çƒå“¡ï¼Œä»–å€‘å°±æœƒå›æ‡‰ä½ ã€‚ï¼‰
#             </div>
#         </div>
#         """, unsafe_allow_html=True)

"""### é–‹ç™¼åœ˜éšŠ"""

# Commented out IPython magic to ensure Python compatibility.
# %%writefile pages/7_ğŸ‘¥_é–‹ç™¼åœ˜éšŠ.py
# import streamlit as st
# from shared.styles import apply_global_style
# 
# apply_global_style()
# 
# st.header("ğŸ‘¥ é–‹ç™¼åœ˜éšŠ")
# st.markdown("---")
# 
# team_members = [{"id": "113403001", "dept": "è³‡ç®¡äºŒ", "name": "å‘‚æ²›ç"}]
# 
# cols = st.columns(4)
# for i, member in enumerate(team_members):
#     with cols[i % 4]:
#         st.markdown(f"""
#         <div class="team-card">
#             <div class="team-name">{member['name']}</div>
#             <div class="team-info">{member['dept']}</div>
#             <div class="team-info">{member['id']}</div>
#         </div>
#         """, unsafe_allow_html=True)

"""### ç¶²å€"""

ngrok.kill()
my_token = userdata.get('AUTHTOKEN')
ngrok.set_auth_token(my_token)

get_ipython().system_raw('nohup streamlit run é¦–é .py --server.port 80 --server.enableCORS false > output.log 2>&1 &')

public_url = ngrok.connect(80)

print(f"Streamlit App URL: {public_url}")
